result <- optimize(SVObj, interval = c(0.2, 10), maximum = FALSE)
HR_sv <- result$minimum
}
for (iFut in 1:nFut) {
SVObj <- function(h) semivar(matrix(as.numeric(OoSSpot - h * (fp[iWin + WinLen, iFut] / sp[iWin + WinLen, ]) * as.matrix(OoSFut, nrow = WinLen)[, iFut]), nrow=WinLen, 1), wHist)
result <- optimize(SVObj, interval = c(-1, 1), maximum = FALSE)
HR_sv <- result$minimum
}
for (iFut in 1:nFut) {
SVObj <- function(h) semivar(matrix(as.numeric(OoSSpot - h * (fp[iWin + WinLen, iFut] / sp[iWin + WinLen, ]) * as.matrix(OoSFut, nrow = WinLen)[, iFut]), nrow=WinLen, 1), wHist)
result <- optimize(SVObj, interval = c(-10, 10), maximum = FALSE)
HR_sv <- result$minimum
}
for (iWin in 1:nWin) {
histSpot <- ld_sp[iWin:iWin + WinLen - 1, ]
# weight for the historical price
wHist <- matrix(1, WinLen, 1) / WinLen
num <- matrix(1, nrow = OoSLen, ncol = 1)
wOoS <- num / OoSLen
OoSSpot <- ld_sp[iWin + WinLen:iWin + WinLen + OoSLen - 1, ]
OoSFut <- ld_fp[iWin + WinLen:iWin + WinLen + OoSLen - 1, ]
for (iFut in 1:nFut) {
SVObj <- function(h) semivar(matrix(as.numeric(OoSSpot - h * (fp[iWin + WinLen, iFut] / sp[iWin + WinLen, ]) * as.matrix(OoSFut, nrow = WinLen)[, iFut]), nrow=WinLen, 1), wHist)
result <- optimize(SVObj, interval = c(-10, 10), maximum = FALSE)
HR_sv <- result$minimum
}
}
HR_sv <- matrix(0, nWin, nFut)
HE_sv <- matrix(0, nWin, nFut)
# out of sample
OoSLen <- WinLen
# Number of windows
nObs <- nrow(ld_sp)
# Number of futures contracts
nFut <- ncol(ld_fp)
# Total number of windows
nWin <- nObs - WinLen - OoSLen + 1
for (iWin in 1:nWin) {
histSpot <- ld_sp[iWin:iWin + WinLen - 1, ]
# weight for the historical price
wHist <- matrix(1, WinLen, 1) / WinLen
num <- matrix(1, nrow = OoSLen, ncol = 1)
wOoS <- num / OoSLen
OoSSpot <- ld_sp[iWin + WinLen:iWin + WinLen + OoSLen - 1, ]
OoSFut <- ld_fp[iWin + WinLen:iWin + WinLen + OoSLen - 1, ]
for (iFut in 1:nFut) {
SVObj <- function(h) semivar(matrix(as.numeric(OoSSpot - h * (fp[iWin + WinLen, iFut] / sp[iWin + WinLen, ]) * as.matrix(OoSFut, nrow = WinLen)[, iFut]), nrow=WinLen, 1), wHist)
result <- optimize(SVObj, interval = c(-10, 10), maximum = FALSE)
HR_sv <- result$minimum
}
# semivariance with no hedging
sv_nh <- semivar(OoSSpot, wOoS)
Prof_h_sv <- matrix(OoSSpot, length(OoSSpot), nFut) - as.numeric(matrix(HR_sv[iWin, ] * (fp[iWin + WinLen, ] / sp[iWin + WinLen, ]), length(OoSSpot), nFut)) * as.matrix(OoSFut)
sv_h <- semivar(Prof_h_sv, wOoS)
HE_sv[iWin, ] <- (sv_h - sv_nh) / (sv_nh)
}
for (iWin in 1:nWin) {
histSpot <- ld_sp[iWin:iWin + WinLen - 1, ]
# weight for the historical price
wHist <- matrix(1, WinLen, 1) / WinLen
num <- matrix(1, nrow = OoSLen, ncol = 1)
wOoS <- num / OoSLen
OoSSpot <- ld_sp[iWin + WinLen:iWin + WinLen + OoSLen - 1, ]
OoSFut <- ld_fp[iWin + WinLen:iWin + WinLen + OoSLen - 1, ]
for (iFut in 1:nFut) {
SVObj <- function(h) semivar(matrix(as.numeric(OoSSpot - h * (fp[iWin + WinLen, iFut] / sp[iWin + WinLen, ]) * as.matrix(OoSFut, nrow = WinLen)[, iFut]), nrow=WinLen, 1), wHist)
result <- optimize(SVObj, interval = c(-10, 10), maximum = FALSE)
HR_sv[iWin, nFut] <- result$minimum
}
}
devtools.desc.suggests
devtools.desc.suggests(stats)
usethis::use_package("stats", "Suggests")
library(stats)
usethis::use_package("stats")
usethis::use_package("stats::fun(optimize")
usethis::use_package("stats::fun(optimize"))
usethis::use_package("stats")
usethis::use_package("stats::fun()")
asfjl
usethis::use_package("aTSA", "Suggests")
iWin
nWin
ld_sp
OoSSpot
iWin+WiWinLen
iWin + WinLen
OoSFut
WinLen
wHist
h=1
semivar(matrix(as.numeric(OoSSpot - h * (fp[iWin + WinLen, iFut] / sp[iWin + WinLen, ]) * as.matrix(OoSFut, nrow = WinLen)[, iFut]), nrow=WinLen, 1), wHist)
iWin=1
nFut=1
h = NA
ob <- function(x) (x-3)^2
lt <- optimize(ob, interval = c(-10, 10), maximum = FALSE)
lt
HE_sv
HR_sv
for (iFut in 1:nFut) {
SVObj <- function(h) semivar(matrix(as.numeric(OoSSpot - h * (fp[iWin + WinLen, iFut] / sp[iWin + WinLen, ]) * as.matrix(OoSFut, nrow = WinLen)[, iFut]), nrow=WinLen, 1), wHist)
result <- optimize(SVObj, interval = c(-10, 10), maximum = FALSE)
HR_sv[iWin, nFut] <- result$minimum
}
for (iFut in 1:nFut) {
SVObj <- function(h) semivar(matrix(as.numeric(OoSSpot - h * (fp[iWin + WinLen, iFut] / sp[iWin + WinLen, ]) * as.matrix(OoSFut, nrow = WinLen)[, iFut]), nrow=WinLen, 1), wHist)
result <- optimize(SVObj, interval = c(-10, 10), maximum = FALSE)
HR_sv[iWin, iFut] <- result$minimum
}
library(readxl)
DATAOBJECT <- read_excel("data/DATAOBJECT.xlsx",
col_names = FALSE)
View(DATAOBJECT)
rda.conversion.saveAsRDA(dat, fxdata)
kagglehouse::rda.conversion.saveAsRDA(dat, fxdata)
Kagglehouse::rda.conversion.saveAsRDA(dat, fxdata)
KaggleHouse::rda.conversion.saveAsRDA(dat, fxdata)
usethis::use_data(DATAOBJECT, compress = "xz")
load("~/new folder/Hedge/data/DATAOBJECT.rda")
devtools::install_github("sieunyi/Hedge, build_vignettes=TRUE")
load("~/new folder/Hedge/data/DATAOBJECT.rda")
View(DATAOBJECT)
DATAOBJECT$...1
x = cbind(DATAOBJECT$...1, DATAOBJECT$...2, DATAOBJECT$...3, DATAOBJECT$...4)
x
mvhr(x, 15)
p <- ncol(x)
n <- nrow(x)
# spot price
sp <- x[, 1]
# futures price
fp <- x[, 2:p]
log(diff(sp))
x <- na.omit(x)
if (WinLen <= 0) {
stop("Window Length should be positive")
}
WinLen=15
# variable setting
p <- ncol(x)
n <- nrow(x)
# spot price
sp <- x[, 1]
# futures price
fp <- x[, 2:p]
lsp <- log(sp)
ld_sp <- lsp[2:n, ] - lsp[1:(n - 1), ]
lfp <- log(fp)
ld_fp <- lfp[2:n, ] - lfp[1:(n - 1), ]
lsp
lsp[2:n,]
lsp[2:,]
lsp[2,]
lsp[,2:p]
fp
sp
fp
log(diff(sp))
diff(log(sp))
diff(log(fp))
mvhr <- function(x, WinLen) {
# Make the dataset balanced & remove NaN observations
# drop the observation with NaN values
x <- na.omit(x)
# Check the compatibility of WinLen
if (WinLen <= 0) {
stop("Window Length should be positive")
}
# variable setting
p <- ncol(x)
n <- nrow(x)
# spot price
sp <- x[, 1]
# futures price
fp <- x[, 2:p]
# take the log difference to remove non-stationarity
ld_sp <- diff(log(sp))
ld_fp <- diff(log(fp))
# Minimum variance Hedge ratio
# WinLen = 15       # window length
# out of sample
OoSLen <- WinLen
# Number of windows
nObs <- nrow(ld_sp)
# Number of futures contracts
nFut <- ncol(ld_fp)
# Total number of windows
nWin <- nObs - WinLen - OoSLen + 1
# construct an empty storage for HR, history data
HR <- matrix(0, nrow = nWin, ncol = nFut)
histSpot <- matrix(0, nrow = WinLen, ncol = 1)
histFut <- matrix(0, nrow = WinLen, ncol = 1)
HE <- matrix(0, nrow = nWin, ncol = nFut)
var_h <- matrix(0, nrow = nWin, ncol = nFut)
var_nh <- matrix(0, nrow = nWin, ncol = nFut)
for (iWin in 1:nWin) {
# historical spot price
histSpot <- ld_sp[iWin:(iWin + WinLen - 1), ]
histFut <- ld_fp[iWin:(iWin + WinLen - 1), ]
HR[iWin, ] <- (sd(histSpot) * cor(histSpot, histFut)) / sd(histFut)
# Out-of-sample is testing the hedge ratio obtained above using samples that were not included in historical data.
# selecting out of sample for spot price
OoSSpot <- ld_sp[(iWin + WinLen):(iWin + WinLen + OoSLen - 1), ]
# selecting out of sample for futures price
OoSFut <- ld_fp[(iWin + WinLen):(iWin + WinLen + OoSLen - 1), ]
# getting a modified hedge ratio
# hr_mod is a scalar
hr_mod <- HR[iWin, ] * fp[(iWin + WinLen), ] / sp[(iWin + WinLen), ]
# prof_nh is length(WinLen) column vector when h = 0, which is equal to spot price.
Prof_nh <- OoSSpot
# prof_h is length(WinLen) x nFut matrix when h is not 0.
Prof_h <- matrix(OoSSpot, length(OoSSpot), nFut, byrow = FALSE) - as.numeric(matrix(hr_mod, OoSLen, 1)) * as.matrix(OoSFut)
# calculate the hedging effectiveness by comparing the variance of the profits for each portfolio.
var_h[iWin, ] <- var(Prof_h)
var_nh[iWin, ] <- var(Prof_nh)
HE[iWin, ] <- (var(Prof_h) - var(Prof_nh)) / var(Prof_nh)
}
return(list(HR = HR, HE = HE))
}
mvhr(x, WinLen=15)
nrow(ld_sp)
nrow(x)
nWin
nFut
p <- ncol(x)
n <- nrow(x)
# spot price
sp <- x[, 1]
# futures price
fp <- x[, 2:p]
# take the log difference to remove non-stationarity
ld_sp <- diff(log(sp))
ld_fp <- diff(log(fp))
# Minimum variance Hedge ratio
# WinLen = 15       # window length
# out of sample
OoSLen <- WinLen
# Number of windows
nObs <- nrow(ld_sp)
# Number of futures contracts
nFut <- ncol(ld_fp)
# Total number of windows
nWin <- nObs - WinLen - OoSLen + 1
WinLEn
WinLen
nWin
nObs
nrow(ld_sp)
ld_sp
nObs <- length(ld_sp)
nObs
nFut <- ncol(ld_fp)
nFut
# Minimum variance Hedge ratio
# WinLen = 15       # window length
# out of sample
OoSLen <- WinLen
# Number of windows
nObs <- length(ld_sp)
# Number of futures contracts
nFut <- ncol(ld_fp)
# Total number of windows
nWin <- nObs - WinLen - OoSLen + 1
# construct an empty storage for HR, history data
HR <- matrix(0, nrow = nWin, ncol = nFut)
histSpot <- matrix(0, nrow = WinLen, ncol = 1)
histFut <- matrix(0, nrow = WinLen, ncol = 1)
HE <- matrix(0, nrow = nWin, ncol = nFut)
var_h <- matrix(0, nrow = nWin, ncol = nFut)
var_nh <- matrix(0, nrow = nWin, ncol = nFut)
for (iWin in 1:nWin) {
# historical spot price
histSpot <- ld_sp[iWin:(iWin + WinLen - 1), ]
histFut <- ld_fp[iWin:(iWin + WinLen - 1), ]
HR[iWin, ] <- (sd(histSpot) * cor(histSpot, histFut)) / sd(histFut)
# Out-of-sample is testing the hedge ratio obtained above using samples that were not included in historical data.
# selecting out of sample for spot price
OoSSpot <- ld_sp[(iWin + WinLen):(iWin + WinLen + OoSLen - 1), ]
# selecting out of sample for futures price
OoSFut <- ld_fp[(iWin + WinLen):(iWin + WinLen + OoSLen - 1), ]
# getting a modified hedge ratio
# hr_mod is a scalar
hr_mod <- HR[iWin, ] * fp[(iWin + WinLen), ] / sp[(iWin + WinLen), ]
# prof_nh is length(WinLen) column vector when h = 0, which is equal to spot price.
Prof_nh <- OoSSpot
# prof_h is length(WinLen) x nFut matrix when h is not 0.
Prof_h <- matrix(OoSSpot, length(OoSSpot), nFut, byrow = FALSE) - as.numeric(matrix(hr_mod, OoSLen, 1)) * as.matrix(OoSFut)
# calculate the hedging effectiveness by comparing the variance of the profits for each portfolio.
var_h[iWin, ] <- var(Prof_h)
var_nh[iWin, ] <- var(Prof_nh)
HE[iWin, ] <- (var(Prof_h) - var(Prof_nh)) / var(Prof_nh)
}
iWin=1
histSpot <- ld_sp[iWin:(iWin + WinLen - 1), ]
histSpot <- as.matrix(ld_sp[iWin:(iWin + WinLen - 1), ])
ld_sp[1:15,]
ld_sp
ld_fp
ld_sp <- as.vector(ld_sp)
ld_sp <- as.vector(ld_sp)
ld_sp <- as.matrix(ld_sp)
histSpot <- ld_sp[iWin:(iWin + WinLen - 1), ]
mvhr <- function(x, WinLen) {
# Make the dataset balanced & remove NaN observations
# drop the observation with NaN values
x <- na.omit(x)
# Check the compatibility of WinLen
if (WinLen <= 0) {
stop("Window Length should be positive")
}
# variable setting
p <- ncol(x)
n <- nrow(x)
# spot price
sp <- x[, 1]
# futures price
fp <- x[, 2:p]
# take the log difference to remove non-stationarity
ld_sp <- diff(log(sp))
ld_fp <- diff(log(fp))
# Minimum variance Hedge ratio
# WinLen = 15       # window length
# out of sample
OoSLen <- WinLen
# Number of windows
nObs <- length(ld_sp)
# Number of futures contracts
nFut <- ncol(ld_fp)
# Total number of windows
nWin <- nObs - WinLen - OoSLen + 1
# construct an empty storage for HR, history data
HR <- matrix(0, nrow = nWin, ncol = nFut)
histSpot <- matrix(0, nrow = WinLen, ncol = 1)
histFut <- matrix(0, nrow = WinLen, ncol = 1)
HE <- matrix(0, nrow = nWin, ncol = nFut)
var_h <- matrix(0, nrow = nWin, ncol = nFut)
var_nh <- matrix(0, nrow = nWin, ncol = nFut)
for (iWin in 1:nWin) {
# historical spot price
ld_sp <- as.matrix(ld_sp)
histSpot <- ld_sp[iWin:(iWin + WinLen - 1), ]
histFut <- ld_fp[iWin:(iWin + WinLen - 1), ]
HR[iWin, ] <- (sd(histSpot) * cor(histSpot, histFut)) / sd(histFut)
# Out-of-sample is testing the hedge ratio obtained above using samples that were not included in historical data.
# selecting out of sample for spot price
OoSSpot <- ld_sp[(iWin + WinLen):(iWin + WinLen + OoSLen - 1), ]
# selecting out of sample for futures price
OoSFut <- ld_fp[(iWin + WinLen):(iWin + WinLen + OoSLen - 1), ]
# getting a modified hedge ratio
# hr_mod is a scalar
hr_mod <- HR[iWin, ] * fp[(iWin + WinLen), ] / sp[(iWin + WinLen), ]
# prof_nh is length(WinLen) column vector when h = 0, which is equal to spot price.
Prof_nh <- OoSSpot
# prof_h is length(WinLen) x nFut matrix when h is not 0.
Prof_h <- matrix(OoSSpot, length(OoSSpot), nFut, byrow = FALSE) - as.numeric(matrix(hr_mod, OoSLen, 1)) * as.matrix(OoSFut)
# calculate the hedging effectiveness by comparing the variance of the profits for each portfolio.
var_h[iWin, ] <- var(Prof_h)
var_nh[iWin, ] <- var(Prof_nh)
HE[iWin, ] <- (var(Prof_h) - var(Prof_nh)) / var(Prof_nh)
}
return(list(HR = HR, HE = HE))
}
mvhr(x, WinLen=15)
mvhr <- function(x, WinLen) {
# Make the dataset balanced & remove NaN observations
# drop the observation with NaN values
x <- na.omit(x)
# Check the compatibility of WinLen
if (WinLen <= 0) {
stop("Window Length should be positive")
}
# variable setting
p <- ncol(x)
n <- nrow(x)
# spot price
sp <- x[, 1]
# futures price
fp <- x[, 2:p]
# take the log difference to remove non-stationarity
ld_sp <- diff(log(sp))
ld_fp <- diff(log(fp))
ld_sp <- as.matrix(ld_sp)
sp <- as.matrix(sp)
# Minimum variance Hedge ratio
# WinLen = 15       # window length
# out of sample
OoSLen <- WinLen
# Number of windows
nObs <- nrow(ld_sp)
# Number of futures contracts
nFut <- ncol(ld_fp)
# Total number of windows
nWin <- nObs - WinLen - OoSLen + 1
# construct an empty storage for HR, history data
HR <- matrix(0, nrow = nWin, ncol = nFut)
histSpot <- matrix(0, nrow = WinLen, ncol = 1)
histFut <- matrix(0, nrow = WinLen, ncol = 1)
HE <- matrix(0, nrow = nWin, ncol = nFut)
var_h <- matrix(0, nrow = nWin, ncol = nFut)
var_nh <- matrix(0, nrow = nWin, ncol = nFut)
for (iWin in 1:nWin) {
# historical spot price
histSpot <- ld_sp[iWin:(iWin + WinLen - 1), ]
histFut <- ld_fp[iWin:(iWin + WinLen - 1), ]
HR[iWin, ] <- (sd(histSpot) * cor(histSpot, histFut)) / sd(histFut)
# Out-of-sample is testing the hedge ratio obtained above using samples that were not included in historical data.
# selecting out of sample for spot price
OoSSpot <- ld_sp[(iWin + WinLen):(iWin + WinLen + OoSLen - 1), ]
# selecting out of sample for futures price
OoSFut <- ld_fp[(iWin + WinLen):(iWin + WinLen + OoSLen - 1), ]
# getting a modified hedge ratio
# hr_mod is a scalar
hr_mod <- HR[iWin, ] * fp[(iWin + WinLen), ] / sp[(iWin + WinLen), ]
# prof_nh is length(WinLen) column vector when h = 0, which is equal to spot price.
Prof_nh <- OoSSpot
# prof_h is length(WinLen) x nFut matrix when h is not 0.
Prof_h <- matrix(OoSSpot, length(OoSSpot), nFut, byrow = FALSE) - as.numeric(matrix(hr_mod, OoSLen, 1)) * as.matrix(OoSFut)
# calculate the hedging effectiveness by comparing the variance of the profits for each portfolio.
var_h[iWin, ] <- var(Prof_h)
var_nh[iWin, ] <- var(Prof_nh)
HE[iWin, ] <- (var(Prof_h) - var(Prof_nh)) / var(Prof_nh)
}
return(list(HR = HR, HE = HE))
}
mvhr(x, 15)
# drop the observation with NaN values
x <- na.omit(x)
# Check the compatibility of WinLen
if (WinLen <= 0) {
stop("Window Length should be positive")
}
# variable setting
p <- ncol(x)
n <- nrow(x)
# spot price
sp <- x[, 1]
# futures price
fp <- x[, 2:p]
# take the log difference to remove non-stationarity
ld_sp <- diff(log(sp))
ld_fp <- diff(log(fp))
ld_sp <- as.matrix(ld_sp)
sp <- as.matrix(sp)
# Minimum variance Hedge ratio
# WinLen = 15       # window length
# out of sample
OoSLen <- WinLen
# Number of windows
nObs <- nrow(ld_sp)
# Number of futures contracts
nFut <- ncol(ld_fp)
# Total number of windows
nWin <- nObs - WinLen - OoSLen + 1
# construct an empty storage for HR, history data
HR <- matrix(0, nrow = nWin, ncol = nFut)
histSpot <- matrix(0, nrow = WinLen, ncol = 1)
histFut <- matrix(0, nrow = WinLen, ncol = 1)
HE <- matrix(0, nrow = nWin, ncol = nFut)
var_h <- matrix(0, nrow = nWin, ncol = nFut)
var_nh <- matrix(0, nrow = nWin, ncol = nFut)
for (iWin in 1:nWin) {
# historical spot price
histSpot <- ld_sp[iWin:(iWin + WinLen - 1), ]
histFut <- ld_fp[iWin:(iWin + WinLen - 1), ]
HR[iWin, ] <- (sd(histSpot) * cor(histSpot, histFut)) / sd(histFut)
# Out-of-sample is testing the hedge ratio obtained above using samples that were not included in historical data.
# selecting out of sample for spot price
OoSSpot <- ld_sp[(iWin + WinLen):(iWin + WinLen + OoSLen - 1), ]
# selecting out of sample for futures price
OoSFut <- ld_fp[(iWin + WinLen):(iWin + WinLen + OoSLen - 1), ]
# getting a modified hedge ratio
# hr_mod is a scalar
hr_mod <- HR[iWin, ] * fp[(iWin + WinLen), ] / sp[(iWin + WinLen), ]
# prof_nh is length(WinLen) column vector when h = 0, which is equal to spot price.
Prof_nh <- OoSSpot
# prof_h is length(WinLen) x nFut matrix when h is not 0.
Prof_h <- matrix(OoSSpot, length(OoSSpot), nFut, byrow = FALSE) - as.numeric(matrix(hr_mod, OoSLen, 1)) * as.matrix(OoSFut)
# calculate the hedging effectiveness by comparing the variance of the profits for each portfolio.
var_h[iWin, ] <- var(Prof_h)
var_nh[iWin, ] <- var(Prof_nh)
HE[iWin, ] <- (var(Prof_h) - var(Prof_nh)) / var(Prof_nh)
}
nWin=906
histSpot <- ld_sp[iWin:(iWin + WinLen - 1), ]
histFut <- ld_fp[iWin:(iWin + WinLen - 1), ]
HR[iWin, ] <- (sd(histSpot) * cor(histSpot, histFut)) / sd(histFut)
# Out-of-sample is testing the hedge ratio obtained above using samples that were not included in historical data.
# selecting out of sample for spot price
OoSSpot <- ld_sp[(iWin + WinLen):(iWin + WinLen + OoSLen - 1), ]
# selecting out of sample for futures price
OoSFut <- ld_fp[(iWin + WinLen):(iWin + WinLen + OoSLen - 1), ]
# getting a modified hedge ratio
# hr_mod is a scalar
hr_mod <- HR[iWin, ] * fp[(iWin + WinLen), ] / sp[(iWin + WinLen), ]
# prof_nh is length(WinLen) column vector when h = 0, which is equal to spot price.
Prof_nh <- OoSSpot
Prof_h <- matrix(OoSSpot, length(OoSSpot), nFut, byrow = FALSE) - as.numeric(matrix(hr_mod, OoSLen, 1)) * as.matrix(OoSFut)
var_h[iWin, ] <- var(Prof_h)
iWin=1
var_h[iWin, ] <- var(Prof_h)
prof_h
Prof_h <- matrix(OoSSpot, length(OoSSpot), nFut, byrow = FALSE) - as.numeric(matrix(hr_mod, OoSLen, 1)) * as.matrix(OoSFut)
Prof_h
var(Prof_h)
usethis::use_data(DATAOBJECT, compress = "xz")
load("~/new folder/Hedge/data/DATAOBJECT.rda")
source("hedge.R")
library(readr)
load("~/new folder/Hedge/data/DATAOBJECT.rda")
load("~/new folder/Hedge/data/DATAOBJECT.rda")
load("C:/Users/Si un/Documents/new folder/Hedge/data/DATAOBJECT.rda")
